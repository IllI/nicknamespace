/**
 * Print Job Executor
 * Orchestrates the complete print job workflow including printer communication
 */

import { createClient } from '@supabase/supabase-js';
import { BambuPrinterClient, createPrinterClient } from './bambu-printer-client';
import { DirectPrintJob } from '@/lib/types/direct-print-jobs';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export class PrintJobExecutor {
  private jobId: string;
  private job: DirectPrintJob | null = null;
  private printerClient: BambuPrinterClient | null = null;

  constructor(jobId: string) {
    this.jobId = jobId;
  }

  /**
   * Execute the complete print job workflow
   */
  async executeJob(): Promise<boolean> {
    try {
      console.log(`Starting print job execution: ${this.jobId}`);

      // Step 1: Load job from database
      await this.loadJob();
      if (!this.job) {
        throw new Error('Job not found');
      }

      // Step 2: Update status to downloading
      await this.updateJobStatus('downloading', 'Downloading model from storage');

      // Step 3: Download model file from Supabase Storage
      const modelBuffer = await this.downloadModelFile();
      if (!modelBuffer) {
        throw new Error('Failed to download model file');
      }

      // Step 4: Update status to slicing
      await this.updateJobStatus('slicing', 'Converting model to G-code');

      // Step 5: Convert to G-code (this would call OrcaSlicer)
      const gcodeBuffer = await this.convertToGcode(modelBuffer);
      if (!gcodeBuffer) {
        throw new Error('Failed to convert model to G-code');
      }

      // Step 6: Initialize printer client using IP from database
      await this.initializePrinterClient();
      if (!this.printerClient) {
        throw new Error('Failed to connect to printer');
      }

      // Step 7: Update status to uploading
      await this.updateJobStatus('uploading', 'Uploading G-code to printer');

      // Step 8: Upload G-code to printer
      const uploadSuccess = await this.uploadToprinter(gcodeBuffer);
      if (!uploadSuccess) {
        throw new Error('Failed to upload G-code to printer');
      }

      // Step 9: Start print job on printer
      const printStarted = await this.startPrintOnPrinter();
      if (!printStarted) {
        throw new Error('Failed to start print on printer');
      }

      // Step 10: Update status to printing
      await this.updateJobStatus('printing', 'Print job started on printer');

      // Step 11: Monitor print progress (this would run in background)
      this.startProgressMonitoring();

      console.log(`Print job ${this.jobId} started successfully`);
      return true;

    } catch (error) {
      console.error(`Print job ${this.jobId} failed:`, error);
      await this.updateJobStatus('failed', error instanceof Error ? error.message : 'Unknown error');
      return false;
    }
  }

  /**
   * Load job details from database
   */
  private async loadJob(): Promise<void> {
    const { data, error } = await supabase
      .from('direct_print_jobs')
      .select('*')
      .eq('id', this.jobId)
      .single();

    if (error) {
      throw new Error(`Failed to load job: ${error.message}`);
    }

    this.job = data;
  }

  /**
   * Download model file from Supabase Storage
   */
  private async downloadModelFile(): Promise<Buffer | null> {
    if (!this.job) return null;

    try {
      const { data, error } = await supabase.storage
        .from('3d-models')
        .download(this.job.storage_path);

      if (error) {
        // Try legacy bucket as fallback
        const { data: legacyData, error: legacyError } = await supabase.storage
          .from('stl-files')
          .download(this.job.storage_path);

        if (legacyError) {
          throw new Error(`Failed to download from both buckets: ${error.message}, ${legacyError.message}`);
        }

        return Buffer.from(await legacyData.arrayBuffer());
      }

      return Buffer.from(await data.arrayBuffer());
    } catch (error) {
      console.error('Download error:', error);
      return null;
    }
  }

  /**
   * Convert model to G-code using OrcaSlicer
   * This is a placeholder - you'd integrate with actual OrcaSlicer here
   */
  private async convertToGcode(modelBuffer: Buffer): Promise<Buffer | null> {
    // TODO: Implement actual OrcaSlicer integration
    // For now, return a mock G-code buffer
    console.log('Converting model to G-code (mock implementation)');
    
    // Mock G-code content
    const mockGcode = `
; Generated by OrcaSlicer
; Print job: ${this.job?.filename}
; Date: ${new Date().toISOString()}

G28 ; Home all axes
G1 Z15.0 F6000 ; Move the platform down 15mm
G92 E0 ; Reset extruder
G1 F200 E3 ; Extrude 3mm of filament
G92 E0 ; Reset extruder
G1 F1500 ; Set feedrate

; Start printing
G1 X50 Y50 Z0.3 F5000 ; Move to start position
G1 E0 F1500 ; Reset extruder

; Print layers would go here...

; End of print
G91 ; Relative positioning
G1 E-1 F300 ; Retract the filament
G1 Z+0.5 E-5 X-20 Y-20 F9000 ; Move up and retract
G28 X0 Y0 ; Home X and Y
G90 ; Absolute positioning
M106 S0 ; Turn off cooling fan
M104 S0 ; Turn off extruder
M140 S0 ; Turn off bed
M84 ; Disable motors
`;

    return Buffer.from(mockGcode, 'utf-8');
  }

  /**
   * Initialize printer client using IP from database or environment
   */
  private async initializePrinterClient(): Promise<void> {
    if (!this.job) return;

    // Use printer IP from database record, environment, or default
    const printerIp = this.job.printer_ip || 
                     process.env.DEFAULT_PRINTER_IP || 
                     '192.168.1.129';
    
    const printerSerial = this.job.printer_serial || 
                         process.env.DEFAULT_PRINTER_SERIAL || 
                         '01P09A3A1800831';

    console.log(`Connecting to printer at ${printerIp} (Serial: ${printerSerial})`);

    this.printerClient = createPrinterClient(printerIp, printerSerial);

    // Test connection
    const connected = await this.printerClient.testConnection();
    if (!connected) {
      throw new Error(`Cannot connect to printer at ${printerIp}`);
    }

    console.log(`Successfully connected to printer at ${printerIp}`);
  }

  /**
   * Upload G-code to printer
   */
  private async uploadToprinter(gcodeBuffer: Buffer): Promise<boolean> {
    if (!this.printerClient || !this.job) return false;

    const filename = `${this.job.filename.replace(/\.[^/.]+$/, '')}.gcode`;
    return await this.printerClient.uploadGcode(gcodeBuffer, filename);
  }

  /**
   * Start print job on printer
   */
  private async startPrintOnPrinter(): Promise<boolean> {
    if (!this.printerClient || !this.job) return false;

    const filename = `${this.job.filename.replace(/\.[^/.]+$/, '')}.gcode`;
    return await this.printerClient.startPrint(filename);
  }

  /**
   * Start monitoring print progress
   */
  private startProgressMonitoring(): void {
    if (!this.printerClient) return;

    // Monitor progress every 30 seconds
    const monitorInterval = setInterval(async () => {
      try {
        const status = await this.printerClient!.getPrintStatus();
        if (!status) return;

        // Update job status based on printer status
        switch (status.status) {
          case 'printing':
            await this.updateJobStatus('printing', `Printing: ${status.progress}% complete`);
            break;
          case 'finished':
            await this.updateJobStatus('complete', 'Print completed successfully');
            clearInterval(monitorInterval);
            break;
          case 'failed':
            await this.updateJobStatus('failed', 'Print failed on printer');
            clearInterval(monitorInterval);
            break;
          case 'paused':
            await this.updateJobStatus('printing', `Print paused at ${status.progress}%`);
            break;
        }
      } catch (error) {
        console.error('Progress monitoring error:', error);
      }
    }, 30000); // 30 seconds

    // Stop monitoring after 24 hours (safety)
    setTimeout(() => {
      clearInterval(monitorInterval);
    }, 24 * 60 * 60 * 1000);
  }

  /**
   * Update job status in database
   */
  private async updateJobStatus(status: string, message?: string): Promise<void> {
    const updates: any = {
      status,
      updated_at: new Date().toISOString(),
    };

    // Set timestamp fields based on status
    switch (status) {
      case 'downloading':
        updates.downloading_started_at = new Date().toISOString();
        break;
      case 'slicing':
        updates.slicing_started_at = new Date().toISOString();
        break;
      case 'uploading':
        updates.uploading_started_at = new Date().toISOString();
        break;
      case 'printing':
        updates.printing_started_at = new Date().toISOString();
        break;
      case 'complete':
        updates.completed_at = new Date().toISOString();
        break;
      case 'failed':
        updates.failed_at = new Date().toISOString();
        if (message) {
          updates.error_message = message;
        }
        break;
    }

    const { error } = await supabase
      .from('direct_print_jobs')
      .update(updates)
      .eq('id', this.jobId);

    if (error) {
      console.error('Failed to update job status:', error);
    } else {
      console.log(`Job ${this.jobId} status updated to: ${status}`);
    }
  }
}

/**
 * Execute a print job by ID
 */
export async function executePrintJob(jobId: string): Promise<boolean> {
  const executor = new PrintJobExecutor(jobId);
  return await executor.executeJob();
}